window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "fraud_detection", "modulename": "fraud_detection", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "fraud_detection.FN_PARAMETERS", "modulename": "fraud_detection", "qualname": "FN_PARAMETERS", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;./config/parameters.xlsx&#x27;"}, {"fullname": "fraud_detection.read_parameters_sheet", "modulename": "fraud_detection", "qualname": "read_parameters_sheet", "kind": "function", "doc": "<p>Reads a specific worksheet from the parameters Excel file.</p>\n\n<p>Parameters:\n    sheet_name (str): The name of the worksheet to read.</p>\n\n<p>Returns:\n    params (pd.DataFrame): DataFrame containing the sheet's contents.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">sheet_name</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fraud_detection.filepaths", "modulename": "fraud_detection", "qualname": "filepaths", "kind": "variable", "doc": "<p></p>\n", "default_value": "           parameter                                              value                                        description\n0          data_file                             ./data/sample_data.csv  File path of the base survey data file with co...\n1       flagged_file                            ./data/flagged_data.csv  File path of the output file with algorithmic ...\n2   world_shape_file  ./config/world-administrative-boundaries/world...  File path of the shape (.shp) file. Required t...\n3      figure_folder                                         ./figures/                       Folder path to save figures.\n4        manual_file                            ./data/flagged_data.csv  File path of the file with both algorithmic fl...\n5  final_output_file                                  ./data/output.csv  File path of the file with the final flag comb...\n6         fuzzy_file                                   ./data/fuzzy.csv  File path to create optional file that contain..."}, {"fullname": "fraud_detection.summary_wrapper", "modulename": "fraud_detection", "qualname": "summary_wrapper", "kind": "function", "doc": "<p>Wrapper function to run a method, log execution time and flag summary,\nand handle exceptions gracefully without interrupting the pipeline.</p>\n\n<p>Parameters:\n    func (function): The function to be wrapped.</p>\n\n<p>Returns:\n    function: A wrapped version of the input function.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">func</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fraud_detection.check_ValueInRange", "modulename": "fraud_detection", "qualname": "check_ValueInRange", "kind": "function", "doc": "<p>Adds a flag column to the dataframe if the column value is within the threshold.</p>\n\n<p>Parameters:\n    df (pd.DataFrame) : Dataframe with relevant data.\n    flag_name (str) : Flag name.\n    column_name (str) : Column name to check for threshold.\n    lower_threshold (float) : Values &gt;= lower threshold value are flagged.\n    upper_threshold (float) : Values &lt;= upper threshold value are flagged.</p>\n\n<p>Returns:\n    df (pd.DataFrame) : Dataframe with the flag.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df</span>, </span><span class=\"param\"><span class=\"n\">flag_name</span>, </span><span class=\"param\"><span class=\"n\">column_name</span>, </span><span class=\"param\"><span class=\"n\">lower_threshold</span>, </span><span class=\"param\"><span class=\"n\">upper_threshold</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fraud_detection.check_CustomCondition", "modulename": "fraud_detection", "qualname": "check_CustomCondition", "kind": "function", "doc": "<p>Adds a flag column to the dataframe based on the given boolean condition.</p>\n\n<p>Parameters:\n    df (pd.DataFrame) : Dataframe with relevant columns.\n    flag_name (str) : Flag name.\n    condition (str) : A Boolean condition written in Pandas evaluate expression format. \n        See <a href=\"https://pandas.pydata.org/docs/reference/api/pandas.eval.html\">https://pandas.pydata.org/docs/reference/api/pandas.eval.html</a> for details.</p>\n\n<p>Returns:\n    df (pd.DataFrame) : Dataframe with flag.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df</span>, </span><span class=\"param\"><span class=\"n\">flag_name</span>, </span><span class=\"param\"><span class=\"n\">condition</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fraud_detection.check_ReverseCodedResponse", "modulename": "fraud_detection", "qualname": "check_ReverseCodedResponse", "kind": "function", "doc": "<p>Adds a flag column to the dataframe if the mean score of reverse-coded items is negatively correlated to the mean score of their counterparts.\nThe method normalizes the items based on min_score and max_score, and removes recoding artifacts (e.g., -99 for unanswered items). \nThis method can be applied to constructs that should be negatively correlated as well. </p>\n\n<p>Parameters:\n    df (pd.DataFrame) : DataFrame with relevant columns.\n    flag_name (str) : Flag name.\n    positive_columns (List[str]) : List of column names representing positive responses.\n    negative_columns (List[str]) : List of column names representing negative responses.\n    min_score (int) : Minimum possible score for the columns.\n    max_score (int) : Maximum possible score for the columns.\n    max_correlation (float) : Correlation above which the data is flagged.</p>\n\n<p>Returns:\n    df (pd.DataFrame) :Dataframe with the flag.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">df</span>,</span><span class=\"param\">\t<span class=\"n\">flag_name</span>,</span><span class=\"param\">\t<span class=\"n\">positive_columns</span>,</span><span class=\"param\">\t<span class=\"n\">negative_columns</span>,</span><span class=\"param\">\t<span class=\"n\">min_score</span>,</span><span class=\"param\">\t<span class=\"n\">max_score</span>,</span><span class=\"param\">\t<span class=\"n\">max_correlation</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fraud_detection.check_SuspiciousCharacter", "modulename": "fraud_detection", "qualname": "check_SuspiciousCharacter", "kind": "function", "doc": "<p>Adds a flag column to the dataframe if there are suspicious characters (e.g., non-breaking character) in text response(s).</p>\n\n<p>Parameters:\n    df (pd.DataFrame) : Dataframe with relevant columns.\n    flag_name (str) : Flag name.\n    list_of_columns (List[str]) : List of column names with text responses.\n    list_of_chars (List[str]) : List of suspicious characters to look for. Defaults to [\"\u00a0\"].\n        \"\u00a0\": ASCII for the non-breaking character.</p>\n\n<p>Returns:\n    df (pd.DataFrame) : Dataframe with flag.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df</span>, </span><span class=\"param\"><span class=\"n\">flag_name</span>, </span><span class=\"param\"><span class=\"n\">list_of_columns</span>, </span><span class=\"param\"><span class=\"n\">list_of_chars</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">&#39;</span><span class=\"se\">\\xa0</span><span class=\"s1\">&#39;</span><span class=\"p\">]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fraud_detection.check_SuspiciousName", "modulename": "fraud_detection", "qualname": "check_SuspiciousName", "kind": "function", "doc": "<p>Adds a flag column to the dataframe for suspicious response to first name and last name columns.\nThis flag only works if the first name and last name are collectde in two separate text responses. \nA response is considered suspicious if any one of the name fields repeats a word (while ignoring initials) from the other name field.</p>\n\n<p>Parameters:\n    df (pd.DataFrame) : Dataframe with relevant columns.\n    flag_name (str) : Flag name. \n    column_first_name (str) : Column name for the first name.\n    column_last_name (str) : Column name for the last name.\n    min_word_length (int) : Minimum length of a word to be considered for matching.\n        Defaults to the recommended value of 2 to avoid initials. </p>\n\n<p>Returns:\n    df (pd.DataFrame) : Dataframe with flag.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">df</span>,</span><span class=\"param\">\t<span class=\"n\">flag_name</span>,</span><span class=\"param\">\t<span class=\"n\">column_first_name</span>,</span><span class=\"param\">\t<span class=\"n\">column_last_name</span>,</span><span class=\"param\">\t<span class=\"n\">min_word_length</span><span class=\"o\">=</span><span class=\"mi\">2</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fraud_detection.check_IPLocation", "modulename": "fraud_detection", "qualname": "check_IPLocation", "kind": "function", "doc": "<p>Adds a region location column <code>IPLocation</code> and a flag column to the dataframe based on the IP address.</p>\n\n<p>Parameters:\n    df (pd.DataFrame) : Dataframe with relevant columns.\n    flag_name (str) : Flag name.\n    column_ip (str) : Column name for IP address. \n    target_region (str) : Region name that should not be flagged. See the notes below for details. Defaults to 'country'.\n    flag_missing (bool) : Should missing data be flagged? True means missing data is flagged.\n    region_level (str) : The geographic level of the region to check. Can be either 'country', 'state', or 'city'. \n        For example, 'country' as \"US\", 'state' as \"California\", and 'city' as \"Mountain View\".</p>\n\n<p>Returns:\n    df (pd.DataFrame) : Dataframe with flag.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">df</span>,</span><span class=\"param\">\t<span class=\"n\">flag_name</span>,</span><span class=\"param\">\t<span class=\"n\">column_ip</span>,</span><span class=\"param\">\t<span class=\"n\">target_region</span>,</span><span class=\"param\">\t<span class=\"n\">flag_missing</span>,</span><span class=\"param\">\t<span class=\"n\">region_level</span><span class=\"o\">=</span><span class=\"s1\">&#39;country&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fraud_detection.check_LatLongLocation", "modulename": "fraud_detection", "qualname": "check_LatLongLocation", "kind": "function", "doc": "<p>Adds a country column <code>LatLongLocation</code> and a flag column to the dataframe based on Latitude-Longtitude.</p>\n\n<p>Parameters:\n    df (pd.DataFrame) : Dataframe with relevant columns.\n    flag_name (str) : Flag name.\n    column_latitude (str) : Column name for Latitude.\n    column_longitude (str) : Column name for Longitude.\n    target_country (str) : Country name that should not be flagged. Verifies against the country's full name (e.g., \"United States of America\").\n    flag_missing (bool) : Should missing data be flagged? True means missing data is flagged.</p>\n\n<p>Returns:\n    df (pd.DataFrame) : Dataframe with flag.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">df</span>,</span><span class=\"param\">\t<span class=\"n\">flag_name</span>,</span><span class=\"param\">\t<span class=\"n\">column_latitude</span>,</span><span class=\"param\">\t<span class=\"n\">column_longitude</span>,</span><span class=\"param\">\t<span class=\"n\">target_country</span>,</span><span class=\"param\">\t<span class=\"n\">flag_missing</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fraud_detection.check_MultipleIPAttempts", "modulename": "fraud_detection", "qualname": "check_MultipleIPAttempts", "kind": "function", "doc": "<p>Adds a flag column to the dataframe for multiple attempts from the same IP network (i.e., the first three octets; e.g., 8.8.8).\nAlso adds a <code>IPNetwork</code> columns to the dataframe. \nThe function can be defined to provide a lower bound and an upper bound to count the attempts. \nIt can also be modified to consider a specific type of attempt (e.g., successful or incomplete). </p>\n\n<p>Parameters:\n    df (pd.DataFrame) : Dataframe with relevant columns.\n    flag_name (str) : Flag name.\n    column_ip (str) : Column name with IP address.\n    column_success (str) : Column name with a non-empty response treated as a successful attempt.\n        \"column_success\" should typically be a question towards the end of the survey.\n    num_attempts_lower (int) : Minimum number of attempts from the same IP to be flagged (&gt;=).\n    num_attempts_upper (int) : Maximum number of attempts from the same IP to be flagged (&lt;=).\n        Defaults to np.inf.\n    attempt_type (str) : Type of attempt to flag. Defaults to 'successful'.\n        - 'successful' : attempts have a response for the <code>column_success</code> question.\n        - 'unsuccessful' : attempts do not have a response for the <code>column_success</code> question.\n        - 'incomplete' : attempts have no response for the <code>column_success</code> question and has no terminate flag. A subset of 'unsuccessful' attempts.\n        - 'failed' : attempts have no response for the <code>column_success</code> question and has a terminate flag. A subset of 'unsuccessful' attempts.\n        - 'all' : attempts irrespective of if it is successful or not.\n    column_terminate (str) : Column name with terminate flag. Optional for 'successful' attempt.</p>\n\n<p>Returns:\n    df (pd.DataFrame) : Dataframe with flag.</p>\n\n<p>Notes:\n    Qualtrics can recode \"Seen but unanswered questions\" as -99. These are treated as \"successful\".\n    Qualtrics <code>Q_TerminateFlag</code> column marks unsuccessful responses as \"Screened\" or \"QuotaMet\".\n    A terminate flag (like <code>Q_TerminateFlag</code>) is required for 'incomplete' and 'failed' attempts.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">df</span>,</span><span class=\"param\">\t<span class=\"n\">flag_name</span>,</span><span class=\"param\">\t<span class=\"n\">column_ip</span>,</span><span class=\"param\">\t<span class=\"n\">column_success</span>,</span><span class=\"param\">\t<span class=\"n\">num_attempts_lower</span>,</span><span class=\"param\">\t<span class=\"n\">num_attempts_upper</span><span class=\"o\">=</span><span class=\"n\">inf</span>,</span><span class=\"param\">\t<span class=\"n\">attempt_type</span><span class=\"o\">=</span><span class=\"s1\">&#39;successful&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">column_terminate</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fraud_detection.check_BurstResponses", "modulename": "fraud_detection", "qualname": "check_BurstResponses", "kind": "function", "doc": "<p>Adds a flag column to the dataframe for burst of responses with similar start times and durations.\nAdds an additional column with number of burst responses <code>NumBurstResponses</code>.\nThis method implements a lower bound and an upper bound for start time and duration differences to allow for graded flagging. </p>\n\n<p>Parameters:\n    df (pd.DataFrame) : Dataframe with relevant columns.\n    flag_name (str) : Flag name.\n    column_start_time (str) : Column name for survey start date and time.\n    column_duration (str) : Column name for survey duration.\n    max_start_time_difference (int) : Maximum absolute difference between start times.\n    max_duration_difference (int) : Maximum absolute difference between survey durations.\n    unflag_start_time_difference (int) : Maximum start time difference for not flagging the responses.\n    unflag_duration_difference (int) : Maximum duration difference for not flagging the responses.</p>\n\n<p>Returns:\n    df (pd.DataFrame) : Dataframe with flag.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">df</span>,</span><span class=\"param\">\t<span class=\"n\">flag_name</span>,</span><span class=\"param\">\t<span class=\"n\">column_start_time</span>,</span><span class=\"param\">\t<span class=\"n\">column_duration</span>,</span><span class=\"param\">\t<span class=\"n\">max_start_time_difference</span>,</span><span class=\"param\">\t<span class=\"n\">max_duration_difference</span>,</span><span class=\"param\">\t<span class=\"n\">unflag_start_time_difference</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">unflag_duration_difference</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fraud_detection.check_DuplicatedText", "modulename": "fraud_detection", "qualname": "check_DuplicatedText", "kind": "function", "doc": "<p>Adds a flag column to the dataframe for duplicated text response of specified length.</p>\n\n<p>Parameters:\n    df (pd.DataFrame) : Dataframe with relevant columns.\n    flag_name (str) : Flag name.\n    list_of_columns (List[str]) : List of column names for text responses.\n    min_length (int) : Minimum string length of text responses.\n    max_length (int) : Maximum string length of text responses.\n    search_strategy (str) : Search strategy to mark duplicates. Defaults to 'column'.\n        - 'column' looks for duplicates within each text column and flags if any of the columns contains a duplicate. \n            This strategy creates flags for individual columns as well.\n        - 'all' looks for duplicates across all text columns.\n    create_column_flag (boolean): Bollean to add column-wise flag. Defaults to False.</p>\n\n<p>Returns:\n    df (pd.DataFrame) : Dataframe with flag.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">df</span>,</span><span class=\"param\">\t<span class=\"n\">flag_name</span>,</span><span class=\"param\">\t<span class=\"n\">list_of_columns</span>,</span><span class=\"param\">\t<span class=\"n\">min_length</span>,</span><span class=\"param\">\t<span class=\"n\">max_length</span>,</span><span class=\"param\">\t<span class=\"n\">search_strategy</span><span class=\"o\">=</span><span class=\"s1\">&#39;column&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">create_column_flag</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fraud_detection.decode_special_floats", "modulename": "fraud_detection", "qualname": "decode_special_floats", "kind": "function", "doc": "<p>Converts the special values (e.g., infinity) in the JSON object in the parameters file to Python numeric values. \nThe parameters file accepts the following values:\n    Positive infinity as \"infinity\" or \"inf\".\n    Negative infinity as \"-infinity\" or \"-inf\".\n    Empty or missing values as \"nan\", \"nil\", or \"none\".\n    True as \"true\".\n    False as \"false\".</p>\n\n<p>Parameters:\n    dct (dict) : Dictionary with JSON values.</p>\n\n<p>Returns:\n    dct (dict) : Dictionary with corresponding Python values.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dct</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fraud_detection.flag_responses", "modulename": "fraud_detection", "qualname": "flag_responses", "kind": "function", "doc": "<p>Applies the flags provided by the user. </p>\n\n<p>Parameters:\n    df (pd.DataFrame) : Dataframe with survey data. \n    params_sheet (str) : Excel sheet name in the parameters file with flag information ('flags')\n        Must contain columns 'flag_name', 'method_name', 'flag_group', 'use_flag', 'parameters'.\n    add_string (boolean) : Whether to add string-formatted columns for activated flags and flag groups. Defaults to True.</p>\n\n<p>Returns:\n    df (pd.DataFrame) : Dataframe with added flag and flag group columns.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df</span>, </span><span class=\"param\"><span class=\"n\">params_sheet</span>, </span><span class=\"param\"><span class=\"n\">add_string</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fraud_detection.classify_responses", "modulename": "fraud_detection", "qualname": "classify_responses", "kind": "function", "doc": "<p>Applies fraud classification rules loaded from an Excel file. Rules must be listed in the descending order of importance.</p>\n\n<p>Parameters:\n    df (pd.DataFrame) : Dataframe with flag groups and relevant indicators.\n    params_sheet (str) : Excel sheet name in parametrs file with rule logic ('initial_classification_rules').\n        Must contain columns 'rule_num', 'condition_expr', 'classification', 'use_rule'.</p>\n\n<p>Returns:\n    classified_rules (pd.DataFrame) : Dataframe with flag <code>classification</code> and <code>rule_num</code> columns.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df</span>, </span><span class=\"param\"><span class=\"n\">params_sheet</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fraud_detection.print_flag_counts", "modulename": "fraud_detection", "qualname": "print_flag_counts", "kind": "function", "doc": "<p>Prints out simple counts of flags and flag groups. </p>\n\n<p>Parameters:\n    df (pd.DataFrame) : Dataframe with survey data. \n    params_sheet (str) : Excel sheet name with flag information ('flags').\n        Must contain columns 'flag_name', 'method_name', 'flag_group', 'use_flag', 'parameters'.</p>\n\n<p>Returns:\n    None : This function prints response classification counts.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df</span>, </span><span class=\"param\"><span class=\"n\">params_sheet</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fraud_detection.print_classification_counts", "modulename": "fraud_detection", "qualname": "print_classification_counts", "kind": "function", "doc": "<p>Prints out simple counts of flags and flag groups. </p>\n\n<p>Parameters:\n    df (pd.DataFrame) : Dataframe with survey data. \n    flag_column (str) : Column name for the flag classification. \n        'FLAG' for algorithmic flags, 'MANUAL_FLAG' for manual check flags, 'FINAL_FLAG' for combined flags. </p>\n\n<p>Returns:\n    None : This function prints flag counts and flag group counts.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">df</span>, </span><span class=\"param\"><span class=\"n\">flag_column</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fraud_detection.plot_flag_cooccurrence_heatmap", "modulename": "fraud_detection", "qualname": "plot_flag_cooccurrence_heatmap", "kind": "function", "doc": "<p>Plots a square heatmap of co-occurrence between flags (or flag groups) and the response classification.</p>\n\n<p>Parameters:\n    df (pd.DataFrame) : Dataframe with survey data and flags.\n    flag_columns (List[str]) : Column names containing the classification (e.g., 'FLAG', 'MANUAL_FLAG', or 'FINAL_FLAG').\n    params_sheet (str) : Excel sheet name with flag information ('flags').\n        Must contain columns 'flag_name', 'method_name', 'flag_group', 'use_flag', 'parameters'.\n    use_groups (bool) : If True, use flag groups instead of individual flags.\n    save_folder (str) : Optional folder path to save the heatmap.\n    display_figure (bool) : If True, display created figures. Defaults to True.</p>\n\n<p>Returns:\n    None : Displays a seaborn heatmap.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">df</span>,</span><span class=\"param\">\t<span class=\"n\">flag_columns</span>,</span><span class=\"param\">\t<span class=\"n\">params_sheet</span>,</span><span class=\"param\">\t<span class=\"n\">use_groups</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">save_folder</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">display_figure</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();